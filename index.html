</div>

          <div class="divider"></div>

          <div class="statbox">
            <div class="row" style="align-items:center; justify-content:space-between;">
              <b style="font-size:13px;">Controle de Habilidades</b>
              <span class="muted">bloquear/desbloquear por jogador</span>
            </div>
            <div class="divider"></div>
            <div class="list" id="gmAbilitiesList"></div>

            <div class="divider"></div>

            <b style="font-size:13px;">Criar habilidade (global)</b>
            <div class="grid" style="gap:10px; margin-top:10px;">
              <input id="abName" placeholder="Nome (ex.: Golpe Sombrio)" />
              <div class="row">
                <input id="abCost" inputmode="numeric" class="mono" placeholder="Custo MP (opcional)" />
                <input id="abTag" placeholder="Tag curta (ex.: dano, cura, util)" />
              </div>
              <textarea id="abDesc" placeholder="DescriÃ§Ã£o curta (1-2 linhas)"></textarea>
              <button class="btn small primary" id="abCreate">Adicionar habilidade</button>
            </div>
          </div>
        </div>

        <div class="card">
          <h2><span>Combate</span><span class="muted">grid + monstro</span></h2>

          <div class="statbox">
            <b style="font-size:13px;">Grid do mapa</b>
            <div class="row" style="margin-top:10px;">
              <div style="flex:1; min-width:140px;">
                <label>Largura (W)</label>
                <input id="gridW" inputmode="numeric" class="mono" placeholder="10" />
              </div>
              <div style="flex:1; min-width:140px;">
                <label>Altura (H)</label>
                <input id="gridH" inputmode="numeric" class="mono" placeholder="10" />
              </div>
              <div style="width:170px;">
                <label>&nbsp;</label>
                <button class="btn small primary" id="gridSave">Salvar grid</button>
              </div>
            </div>
          </div>

          <div class="divider"></div>

          <div class="statbox">
            <b style="font-size:13px;">Spawnar monstro (no combate: sÃ³ nome)</b>
            <div class="grid" style="gap:10px; margin-top:10px;">
              <input id="mName" placeholder="Nome do monstro (ex.: Abissal Menor)" />
              <div class="row">
                <input id="mSprite" placeholder="Sprite (emoji ou URL) ex.: ðŸ‘¹" />
                <input id="mPosX" inputmode="numeric" class="mono" placeholder="pos x" />
                <input id="mPosY" inputmode="numeric" class="mono" placeholder="pos y" />
              </div>
              <div class="row">
                <button class="btn primary" id="mSpawn">Spawnar / Atualizar</button>
                <button class="btn bad" id="mClear">Remover monstro</button>
              </div>
            </div>
          </div>

          <div class="divider"></div>

          <div class="statbox">
            <b style="font-size:13px;">Mapa (prÃ©via do mestre)</b>
            <p class="hint">O mestre pode arrastar QUALQUER token no mapa.</p>
            <div id="gmBattleMap" class="battle-map" style="margin-top:10px;"></div>
          </div>
        </div>
      </div>
    </div>
  </section>
</main>

<div class="toast" id="toast"></div>
<div id="debugBox" style="position:fixed;top:10px;left:10px;z-index:99999;background:#000c;color:#fff;padding:8px 10px;border-radius:10px;font:12px monospace;max-width:90vw">
  debug: (carregando...)
</div>

<script>
  // =========================================
  // Eldora â€” Realtime com Supabase (Corrigido)
  // =========================================

  // Tratamento global de erros para ajudar no debug
  window.addEventListener("error", (e) => {
    alert("ERRO JS:\n" + (e.message || e.error || "desconhecido"));
  });
  window.addEventListener("unhandledrejection", (e) => {
    alert("PROMISE REJEITADA:\n" + (e.reason?.message || e.reason || "desconhecido"));
  });

  /* ======= CONFIG: cole suas credenciais aqui ======= */
  const SUPABASE_URL = "https://nnlgtpqcyjrszrlaftnf.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5ubGd0cHFjeWpyc3pybGFmdG5mIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjYxNTEzMDQsImV4cCI6MjA4MTcyNzMwNH0.o97LxQYQR3THeK7geVQgk7PbGkqii4Yuf_3A8_O1_i4";

  const LOCAL_KEY = "eldora_realtime_local_v1";

  // UtilitÃ¡rios
  const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
  const toInt = (v, fallback=0) => {
    const n = parseInt(String(v).trim(), 10);
    return Number.isFinite(n) ? n : fallback;
  };

  function uid(){ return Math.random().toString(16).slice(2) + Date.now().toString(16); }
  
  function escapeHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function toast(msg){
    const el = document.getElementById("toast");
    el.textContent = msg;
    el.style.display = "block";
    clearTimeout(toast._t);
    toast._t = setTimeout(() => el.style.display = "none", 1800);
  }

  function setSavedBadge(ok){
    const badge = document.getElementById("saveBadge");
    if(badge) badge.textContent = ok ? "Salvo âœ“" : "Salvandoâ€¦";
  }

  function setRT(status){
    const b = document.getElementById("rtBadge");
    if(!b) return;
    if(status === "online"){ 
      b.textContent = "Realtime"; 
      b.style.borderColor = "rgba(34,197,94,.75)"; 
      b.style.background = "rgba(34,197,94,.10)"; 
    }
    else if(status === "connecting"){ 
      b.textContent = "Conectandoâ€¦"; 
      b.style.borderColor = "rgba(245,158,11,.75)"; 
      b.style.background = "rgba(245,158,11,.10)"; 
    }
    else { 
      b.textContent = "Offline"; 
      b.style.borderColor = "rgba(36,48,70,.8)"; 
      b.style.background = "rgba(31,41,55,.55)"; 
    }
  }

  // Teste de conexÃ£o manual
  const btnTest = document.getElementById("btnTest");
  if(btnTest) {
    btnTest.addEventListener("click", async () => {
      try{
        if(!canUseSupabase()){
          alert("VocÃª nÃ£o colou SUPABASE_URL e SUPABASE_ANON_KEY corretamente no HTML.");
          return;
        }
        if(!supabase){
          supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        }

        const code = (document.getElementById("roomCode").value || "ELDORA1").trim();

        // 1) tenta UPSERT
        const up = await supabase.from("rooms").upsert({
          code,
          state: { ping: Date.now() },
          updated_at: new Date().toISOString()
        }, { onConflict: "code" });

        if(up.error) throw up.error;

        // 2) tenta LER
        const rd = await supabase.from("rooms").select("state").eq("code", code).single();
        if(rd.error) throw rd.error;

        alert("âœ… OK! Conectou, escreveu e leu.\nstate=" + JSON.stringify(rd.data.state));
      }catch(e){
        alert("âŒ Erro:\n" + (e?.message || JSON.stringify(e)));
      }
    });
  }

  /* ===== State ===== */
  const defaultState = () => ({
    gmPin: "1234",
    combat: { gridW: 10, gridH: 10 },
    abilities: [
      { id: uid(), name: "Ataque BÃ¡sico", cost: 0, tag: "dano", desc: "Um golpe simples com sua arma." },
      { id: uid(), name: "Defesa", cost: 0, tag: "util", desc: "Aumenta sua resistÃªncia por um turno (narrativo)." },
      { id: uid(), name: "Pulso Arcano", cost: 3, tag: "magia", desc: "Um disparo mÃ¡gico de curto alcance." }
    ],
    players: [
      { id: uid(), name: "Zyra", pin: "1111", sprite: "ðŸ‰", hpNow: 18, hpMax: 18, mpNow: 10, mpMax: 10, locked: [], pos: { x: 2, y: 4 } },
      { id: uid(), name: "Kayron", pin: "2222", sprite: "ðŸ—¡ï¸", hpNow: 16, hpMax: 16, mpNow: 12, mpMax: 12, locked: [], pos: { x: 4, y: 4 } }
    ],
    monster: null // { name, sprite, pos:{x,y} }
  });

  function normalizeState(s){
    const d = defaultState();
    if(!s || typeof s !== "object") return d;

    if(typeof s.gmPin !== "string") s.gmPin = d.gmPin;
    if(!s.combat) s.combat = { gridW: 10, gridH: 10 };
    s.combat.gridW = Math.max(2, toInt(s.combat.gridW, 10));
    s.combat.gridH = Math.max(2, toInt(s.combat.gridH, 10));

    if(!Array.isArray(s.abilities)) s.abilities = d.abilities;
    if(!Array.isArray(s.players)) s.players = d.players;

    s.abilities.forEach(a => { if(!a.id) a.id = uid(); });

    s.players.forEach(p => {
      if(!p.id) p.id = uid();
      if(typeof p.name !== "string") p.name = "HerÃ³i";
      if(typeof p.pin !== "string") p.pin = "0000";
      if(typeof p.sprite !== "string") p.sprite = "ðŸ™‚";
      if(!Array.isArray(p.locked)) p.locked = [];
      if(!p.pos) p.pos = { x:0, y:0 };

      p.hpMax = Math.max(0, toInt(p.hpMax,0));
      p.mpMax = Math.max(0, toInt(p.mpMax,0));
      p.hpNow = clamp(toInt(p.hpNow,0), 0, p.hpMax);
      p.mpNow = clamp(toInt(p.mpNow,0), 0, p.mpMax);

      p.pos.x = clamp(toInt(p.pos.x,0), 0, s.combat.gridW-1);
      p.pos.y = clamp(toInt(p.pos.y,0), 0, s.combat.gridH-1);
    });

    if(s.monster){
      if(typeof s.monster.name !== "string") s.monster.name = "Monstro";
      if(typeof s.monster.sprite !== "string") s.monster.sprite = "ðŸ‘¹";
      if(!s.monster.pos) s.monster.pos = { x: 7, y: 4 };
      s.monster.pos.x = clamp(toInt(s.monster.pos.x,7), 0, s.combat.gridW-1);
      s.monster.pos.y = clamp(toInt(s.monster.pos.y,4), 0, s.combat.gridH-1);
    }

    return s;
  }

  function loadLocal(){
    try{
      const raw = localStorage.getItem(LOCAL_KEY);
      if(!raw) return defaultState();
      return normalizeState(JSON.parse(raw));
    }catch{
      return defaultState();
    }
  }

  let state = loadLocal();
  function saveLocal(){
    setSavedBadge(false);
    localStorage.setItem(LOCAL_KEY, JSON.stringify(state));
    setTimeout(() => setSavedBadge(true), 150);
  }

  /* ===== Supabase (optional) ===== */
  let supabase = null;
  let roomCode = "";
  let rtChannel = null;
  let isConnected = false;
  let suppressRemote = false; 

  const roomCodeInput = document.getElementById("roomCode");
  const roomStatus = document.getElementById("roomStatus");

  function canUseSupabase(){
    return typeof window.supabase !== "undefined"
      && SUPABASE_URL.startsWith("http")
      && SUPABASE_ANON_KEY.length > 30;
  }

  function updateRoomUI(){
    if(roomStatus) roomStatus.textContent = isConnected ? `room:${roomCode}` : "local";
    setRT(isConnected ? "online" : "offline");
  }

  async function ensureRoomExists(code){
    const payload = { code, state, updated_at: new Date().toISOString() };
    const { error } = await supabase.from("rooms").upsert(payload, { onConflict: "code" });
    if(error) throw error;
  }

  async function loadRoomState(code){
    const { data, error } = await supabase.from("rooms").select("state").eq("code", code).single();
    if(error) throw error;
    return normalizeState(data.state);
  }

  let pushTimer = null;
  function schedulePush(reason=""){
    if(!isConnected) return;
    clearTimeout(pushTimer);
    pushTimer = setTimeout(() => pushRoomState(reason), 120);
  }

  async function pushRoomState(reason=""){
    if(!isConnected) return;
    try{
      suppressRemote = true;
      setTimeout(()=> suppressRemote = false, 350);

      const { error } = await supabase
        .from("rooms")
        .update({ state, updated_at: new Date().toISOString() })
        .eq("code", roomCode);

      if(error) throw error;
    }catch(e){
      console.error(e);
      toast("Falha ao salvar no Supabase");
      isConnected = false;
      cleanupRealtime();
      updateRoomUI();
    }
  }

  function cleanupRealtime(){
    if(rtChannel){
      try{ supabase.removeChannel(rtChannel); }catch{}
      rtChannel = null;
    }
  }

  function subscribeRoom(code){
    cleanupRealtime();
    rtChannel = supabase
      .channel("eldora-room-" + code)
      .on("postgres_changes",
        { event: "UPDATE", schema: "public", table: "rooms", filter: `code=eq.${code}` },
        (payload) => {
          if(suppressRemote) return;
          const incoming = normalizeState(payload.new.state);
          state = incoming;
          if(playerAuthedId && !state.players.some(p => p.id === playerAuthedId)) playerLogout();
          renderAll(false);
        }
      )
      .subscribe((status) => {});
  }

  async function connectRoom(code){
    if(!canUseSupabase()){
      toast("Cole SUPABASE_URL e SUPABASE_ANON_KEY no HTML");
      return;
    }
    code = String(code || "").trim();
    if(!code){
      toast("Digite um ROOM CODE");
      return;
    }
    setRT("connecting");

    if(!supabase){
      supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
        realtime: { params: { eventsPerSecond: 10 } }
      });
    }

    try{
      roomCode = code;
      await ensureRoomExists(roomCode);
      const serverState = await loadRoomState(roomCode);
      state = serverState;
      saveLocal();
      subscribeRoom(roomCode);
      isConnected = true;
      updateRoomUI();
      toast("Conectado! Realtime ativo.");
      renderAll(false);
    }catch(e){
      console.error(e);
      isConnected = false;
      cleanupRealtime();
      updateRoomUI();
      toast("Falha ao conectar na sala");
    }
  }

  function disconnectRoom(){
    isConnected = false;
    cleanupRealtime();
    updateRoomUI();
    toast("Desconectado (modo local)");
  }

  document.getElementById("btnConnect").addEventListener("click", () => {
    connectRoom(roomCodeInput.value);
  });
  document.getElementById("btnDisconnect").addEventListener("click", () => {
    disconnectRoom();
  });

  /* ===== Auth ===== */
  let gmAuthed = false;
  let playerAuthedId = null;

  function playerLoginByPin(pin){
    const p = state.players.find(pl => String(pl.pin) === String(pin).trim());
    if(!p) return false;
    playerAuthedId = p.id;
    return true;
  }
  function playerLogout(){ playerAuthedId = null; }
  function getAuthedPlayer(){ return state.players.find(p => p.id === playerAuthedId) || null; }

  /* ===== Tabs ===== */
  const tabs = {
    player: document.getElementById("tabPlayer"),
    combat: document.getElementById("tabCombat"),
    gm: document.getElementById("tabGM")
  };
  const views = {
    player: document.getElementById("viewPlayer"),
    combat: document.getElementById("viewCombat"),
    gm: document.getElementById("viewGM")
  };
  function activateTab(name){
    for(const k of Object.keys(tabs)){
      if(tabs[k]) {
        tabs[k].classList.toggle("active", k === name);
        tabs[k].setAttribute("aria-selected", k === name ? "true" : "false");
      }
      if(views[k]) views[k].style.display = (k === name) ? "" : "none";
    }
    renderAll(false);
  }
  if(tabs.player) tabs.player.addEventListener("click", () => activateTab("player"));
  if(tabs.combat) tabs.combat.addEventListener("click", () => activateTab("combat"));
  if(tabs.gm) tabs.gm.addEventListener("click", () => activateTab("gm"));

  /* ===== Player UI ===== */
  const playerNamePill = document.getElementById("playerNamePill");
  const hpText = document.getElementById("hpText");
  const mpText = document.getElementById("mpText");
  const hpFill = document.getElementById("hpFill");
  const mpFill = document.getElementById("mpFill");
  const playerLockedNotice = document.getElementById("playerLockedNotice");
  const playerStatusInner = document.getElementById("playerStatusInner");
  const abilitiesLockedNotice = document.getElementById("abilitiesLockedNotice");
  const abilitiesInner = document.getElementById("abilitiesInner");
  const abilitiesUnlocked = document.getElementById("abilitiesUnlocked");
  const abilitiesLocked = document.getElementById("abilitiesLocked");

  function renderBar(fillEl, now, max){
    const pct = max > 0 ? (now / max) * 100 : 0;
    fillEl.style.width = clamp(pct, 0, 100).toFixed(1) + "%";
  }

  function renderPlayerGate(){
    const gate = document.getElementById("playerGate");
    const area = document.getElementById("playerArea");
    if(playerAuthedId){ gate.style.display = "none"; area.style.display = ""; }
    else { gate.style.display = ""; area.style.display = "none"; }
  }

  document.getElementById("playerEnter").addEventListener("click", () => {
    const pin = document.getElementById("playerPin").value;
    if(playerLoginByPin(pin)){
      document.getElementById("playerPin").value = "";
      toast("Entrou com sucesso");
      renderAll(false);
    } else toast("PIN invÃ¡lido");
  });
  document.getElementById("playerLogout").addEventListener("click", () => {
    playerLogout();
    toast("Saiu");
    renderAll(false);
  });

  function renderAbilitiesForPlayer(p){
    abilitiesUnlocked.innerHTML = "";
    abilitiesLocked.innerHTML = "";

    const lockedSet = new Set(p.locked || []);
    const unlocked = state.abilities.filter(a => !lockedSet.has(a.id));
    const locked = state.abilities.filter(a => lockedSet.has(a.id));

    const renderOne = (a, isLocked) => {
      const box = document.createElement("div");
      box.className = "ability";
      // CORREÃ‡ÃƒO: Transformado em string com crases
      box.innerHTML = `
        <div class="meta">
          <p class="name">${escapeHtml(a.name)}</p>
          <p class="desc">${escapeHtml(a.desc || "")}</p>
          <p class="desc"><span class="pill mono">MP ${toInt(a.cost,0)}</span> <span class="pill">${escapeHtml(a.tag || "â€”")}</span></p>
        </div>
        <span class="tag ${isLocked ? "locked" : "unlocked"}">${isLocked ? "ðŸ”’ Bloqueada" : "âœ… DisponÃ­vel"}</span>
      `;
      return box;
    };

    if(unlocked.length === 0) abilitiesUnlocked.innerHTML = `<div class="muted">Nenhuma habilidade disponÃ­vel.</div>`;
    else unlocked.forEach(a => abilitiesUnlocked.appendChild(renderOne(a,false)));

    if(locked.length === 0) abilitiesLocked.innerHTML = `<div class="muted">Nenhuma habilidade bloqueada.</div>`;
    else locked.forEach(a => abilitiesLocked.appendChild(renderOne(a,true)));
  }

  function renderPlayer(){
    renderPlayerGate();
    const p = getAuthedPlayer();

    const loggedIn = !!p;
    playerLockedNotice.style.display = loggedIn ? "none" : "";
    playerStatusInner.style.display = loggedIn ? "" : "none";
    abilitiesLockedNotice.style.display = loggedIn ? "none" : "";
    abilitiesInner.style.display = loggedIn ? "" : "none";
    if(!p) return;

    playerNamePill.textContent = p.name;
    // CORREÃ‡ÃƒO: Crases
    hpText.textContent = `${p.hpNow} / ${p.hpMax}`;
    mpText.textContent = `${p.mpNow} / ${p.mpMax}`;
    renderBar(hpFill, p.hpNow, p.hpMax);
    renderBar(mpFill, p.mpNow, p.mpMax);
    renderAbilitiesForPlayer(p);
  }

  function adjustPlayerStat(p, keyNow, delta){
    const keyMax = keyNow === "hpNow" ? "hpMax" : "mpMax";
    p[keyNow] = clamp(toInt(p[keyNow],0) + delta, 0, toInt(p[keyMax],0));
    saveLocal();
    schedulePush("player_stat");
    renderAll(false);
    // CORREÃ‡ÃƒO: Crases
    toast(`${p.name}: ${keyNow === "hpNow" ? "HP" : "MP"} ${delta > 0 ? "+" : ""}${delta}`);
  }

  document.getElementById("hpMinus").addEventListener("click", () => {
    const p = getAuthedPlayer(); if(!p) return;
    const step = toInt(document.getElementById("hpStep").value, 1);
    adjustPlayerStat(p, "hpNow", -Math.abs(step));
  });
  document.getElementById("hpPlus").addEventListener("click", () => {
    const p = getAuthedPlayer(); if(!p) return;
    const step = toInt(document.getElementById("hpStep").value, 1);
    adjustPlayerStat(p, "hpNow", Math.abs(step));
  });
  // CORREÃ‡ÃƒO: Crases
  document.getElementById("hpApplyStep").addEventListener("click", () => toast(`Passo de HP: ${toInt(document.getElementById("hpStep").value, 1)}`));
  
  document.getElementById("mpMinus").addEventListener("click", () => {
    const p = getAuthedPlayer(); if(!p) return;
    const step = toInt(document.getElementById("mpStep").value, 1);
    adjustPlayerStat(p, "mpNow", -Math.abs(step));
  });
  document.getElementById("mpPlus").addEventListener("click", () => {
    const p = getAuthedPlayer(); if(!p) return;
    const step = toInt(document.getElementById("mpStep").value, 1);
    adjustPlayerStat(p, "mpNow", Math.abs(step));
  });
  // CORREÃ‡ÃƒO: Crases
  document.getElementById("mpApplyStep").addEventListener("click", () => toast(`Passo de MP: ${toInt(document.getElementById("mpStep").value, 1)}`));

  /* ===== Combat View ===== */
  document.getElementById("goToPlayer").addEventListener("click", () => activateTab("player"));
  const combatGate = document.getElementById("combatGate");
  const combatInner = document.getElementById("combatInner");
  const mapCard = document.getElementById("mapCard");
  const combatMonsterName = document.getElementById("combatMonsterName");
  const gridInfo = document.getElementById("gridInfo");

  function renderCombat(){
    const p = getAuthedPlayer();
    const loggedIn = !!p;

    combatGate.style.display = loggedIn ? "none" : "";
    combatInner.style.display = loggedIn ? "" : "none";
    mapCard.style.display = loggedIn ? "" : "none";

    // CORREÃ‡ÃƒO: Crases
    gridInfo.textContent = `${state.combat.gridW}Ã—${state.combat.gridH}`;
    combatMonsterName.textContent = state.monster ? state.monster.name : "Nenhum";
    if(loggedIn) renderBattleMaps();
  }

  /* ===== Map + Tokens ===== */
  const battleMap = document.getElementById("battleMap");
  const gmBattleMap = document.getElementById("gmBattleMap");

  function cellSizePct(){
    const w = Math.max(2, toInt(state.combat.gridW, 10));
    const h = Math.max(2, toInt(state.combat.gridH, 10));
    return { w, h, cw: 100/w, ch: 100/h };
  }
  function setMapGridBackground(mapEl){
    const { w, h } = cellSizePct();
    // CORREÃ‡ÃƒO: Crases
    mapEl.style.backgroundSize = `${100/w}% ${100/h}%`;
  }
  function tokenContent(sprite){
    const s = String(sprite || "").trim();
    if(/^(https?:\/\/|data:image\/)/i.test(s)){
      // CORREÃ‡ÃƒO: Crases e string
      return `<img src="${escapeHtml(s)}" alt="" onerror="this.replaceWith(Object.assign(document.createElement('span'),{className:'emoji',textContent:'ðŸ™‚'}))" />`;
    }
    // CORREÃ‡ÃƒO: Crases e string
    return `<span class="emoji">${escapeHtml(s || "ðŸ™‚")}</span>`;
  }
  function canDragToken(tokenType, tokenId){
    if(gmAuthed) return true;
    return tokenType === "player" && tokenId === playerAuthedId;
  }
  function makeToken({id, name, sprite, x, y, type}, mapEl){
    const { cw, ch } = cellSizePct();
    const el = document.createElement("div");
    el.className = "token";
    el.dataset.id = id;
    el.dataset.type = type;

    // CORREÃ‡ÃƒO: Crases
    el.style.left = `${x*cw}%`;
    el.style.top  = `${y*ch}%`;
    el.style.width = `${cw}%`;
    el.style.height = `${ch}%`;

    // CORREÃ‡ÃƒO: Crases
    el.innerHTML = `${tokenContent(sprite)}<span class="label">${escapeHtml(name)}</span>`;
    enableDrag(el, mapEl);
    return el;
  }
  function enableDrag(el, mapEl){
    let dragging = false;

    const pointerDown = (e) => {
      if(!canDragToken(el.dataset.type, el.dataset.id)) return;
      dragging = true;
      el.setPointerCapture?.(e.pointerId);
      e.preventDefault();
    };

    const pointerMove = (e) => {
      if(!dragging) return;
      const rect = mapEl.getBoundingClientRect();
      const { w, h } = cellSizePct();

      const px = clamp(e.clientX - rect.left, 0, rect.width);
      const py = clamp(e.clientY - rect.top, 0, rect.height);

      const cellX = clamp(Math.floor((px / rect.width) * w), 0, w-1);
      const cellY = clamp(Math.floor((py / rect.height) * h), 0, h-1);

      const { cw, ch } = cellSizePct();
      // CORREÃ‡ÃƒO: Crases
      el.style.left = `${cellX*cw}%`;
      el.style.top  = `${cellY*ch}%`;
    };

    const pointerUp = (e) => {
      if(!dragging) return;
      dragging = false;

      const rect = mapEl.getBoundingClientRect();
      const { w, h } = cellSizePct();

      const px = clamp(e.clientX - rect.left, 0, rect.width);
      const py = clamp(e.clientY - rect.top, 0, rect.height);

      const cellX = clamp(Math.floor((px / rect.width) * w), 0, w-1);
      const cellY = clamp(Math.floor((py / rect.height) * h), 0, h-1);

      if(el.dataset.type === "player"){
        const p = state.players.find(pp => pp.id === el.dataset.id);
        if(p) p.pos = { x: cellX, y: cellY };
      } else if(el.dataset.type === "monster"){
        if(state.monster) state.monster.pos = { x: cellX, y: cellY };
      }

      saveLocal();
      schedulePush("drag_token");
      renderAll(false);
    };

    el.addEventListener("pointerdown", pointerDown);
    window.addEventListener("pointermove", pointerMove);
    window.addEventListener("pointerup", pointerUp);
  }

  function renderOneMap(mapEl, mode){
    if(!mapEl) return;
    setMapGridBackground(mapEl);
    mapEl.innerHTML = "";

    const { w, h } = cellSizePct();

    const addPlayerToken = (p) => {
      const pos = p.pos || { x:0, y:0 };
      const x = clamp(toInt(pos.x,0), 0, w-1);
      const y = clamp(toInt(pos.y,0), 0, h-1);
      mapEl.appendChild(makeToken({ id: p.id, type:"player", name: p.name, sprite: p.sprite || "ðŸ™‚", x, y }, mapEl));
    };

    if(mode === "player"){
      const p = getAuthedPlayer();
      if(p) addPlayerToken(p);
    } else {
      state.players.forEach(addPlayerToken);
    }

    if(state.monster){
      const pos = state.monster.pos || { x:7, y:4 };
      const x = clamp(toInt(pos.x,7), 0, w-1);
      const y = clamp(toInt(pos.y,4), 0, h-1);
      mapEl.appendChild(makeToken({ id: "monster", type:"monster", name: state.monster.name || "Monstro", sprite: state.monster.sprite || "ðŸ‘¹", x, y }, mapEl));
    }
  }

  function renderBattleMaps(){
    renderOneMap(battleMap, "player");
    renderOneMap(gmBattleMap, "gm");
  }

  /* ===== GM UI ===== */
  const gmLock = document.getElementById("gmLock");
  const gmPanel = document.getElementById("gmPanel");
  const gmMain = document.getElementById("gmMain");

  const gmEnter = document.getElementById("gmEnter");
  const gmPin = document.getElementById("gmPin");
  const gmLogout = document.getElementById("gmLogout");
  const gmPinNew = document.getElementById("gmPinNew");
  const gmSetPin = document.getElementById("gmSetPin");

  const gmPlayerSelect = document.getElementById("gmPlayerSelect");
  const gmPlayerName = document.getElementById("gmPlayerName");
  const gmHpNow = document.getElementById("gmHpNow");
  const gmHpMax = document.getElementById("gmHpMax");
  const gmMpNow = document.getElementById("gmMpNow");
  const gmMpMax = document.getElementById("gmMpMax");
  const gmPlayerPin = document.getElementById("gmPlayerPin");
  const gmPlayerSprite = document.getElementById("gmPlayerSprite");
  const gmPosX = document.getElementById("gmPosX");
  const gmPosY = document.getElementById("gmPosY");
  const gmSaveStats = document.getElementById("gmSaveStats");
  const gmDeletePlayer = document.getElementById("gmDeletePlayer");
  const gmRenamePlayer = document.getElementById("gmRenamePlayer");
  const btnAddPlayer = document.getElementById("btnAddPlayer");
  const gmAbilitiesList = document.getElementById("gmAbilitiesList");

  let selectedGMPlayerId = state.players[0]?.id ?? null;

  function renderGMAuth(){
    gmLock.style.display = gmAuthed ? "none" : "";
    gmPanel.style.display = gmAuthed ? "" : "none";
    gmMain.style.display = gmAuthed ? "" : "none";
  }

  gmEnter.addEventListener("click", () => {
    const pin = String(gmPin.value || "").trim();
    if(pin && pin === state.gmPin){
      gmAuthed = true;
      gmPin.value = "";
      toast("Mestre autenticado");
      renderAll(false);
    } else toast("PIN incorreto");
  });
  gmLogout.addEventListener("click", () => {
    gmAuthed = false;
    toast("Saiu do painel do mestre");
    renderAll(false);
  });
  gmSetPin.addEventListener("click", () => {
    if(!gmAuthed) return;
    const newPin = String(gmPinNew.value || "").trim();
    if(newPin.length < 3){ toast("PIN muito curto"); return; }
    state.gmPin = newPin;
    gmPinNew.value = "";
    saveLocal();
    schedulePush("gm_pin");
    toast("PIN atualizado");
    renderAll(false);
  });

  function populateGMPlayerSelect(){
    gmPlayerSelect.innerHTML = "";
    state.players.forEach(p => {
      const opt = document.createElement("option");
      opt.value = p.id;
      opt.textContent = p.name;
      gmPlayerSelect.appendChild(opt);
    });
    if(selectedGMPlayerId && state.players.some(p => p.id === selectedGMPlayerId)){
      gmPlayerSelect.value = selectedGMPlayerId;
    } else {
      selectedGMPlayerId = state.players[0]?.id ?? null;
      gmPlayerSelect.value = selectedGMPlayerId ?? "";
    }
  }
  gmPlayerSelect.addEventListener("change", () => {
    selectedGMPlayerId = gmPlayerSelect.value;
    renderAll(false);
  });
  function getGMPlayer(){
    return state.players.find(p => p.id === selectedGMPlayerId) || state.players[0];
  }
  function toggleAbilityLock(player, abilityId){
    player.locked = Array.isArray(player.locked) ? player.locked : [];
    const idx = player.locked.indexOf(abilityId);
    if(idx >= 0) player.locked.splice(idx, 1);
    else player.locked.push(abilityId);
    saveLocal();
    schedulePush("toggle_ability");
  }

  function renderGMAbilitiesForPlayer(p){
    gmAbilitiesList.innerHTML = "";
    const lockedSet = new Set(p.locked || []);

    state.abilities.forEach(a => {
      const row = document.createElement("div");
      row.className = "ability";
      const isLocked = lockedSet.has(a.id);
      // CORREÃ‡ÃƒO: Crases e HTML como string
      row.innerHTML = `
        <div class="meta">
          <p class="name">${escapeHtml(a.name)}</p>
          <p class="desc">${escapeHtml(a.desc || "")}</p>
          <p class="desc"><span class="pill mono">MP ${toInt(a.cost,0)}</span> <span class="pill">${escapeHtml(a.tag || "â€”")}</span></p>
        </div>
        <button class="btn small ${isLocked ? "warn" : "good"}" data-ability="${a.id}">
          ${isLocked ? "Desbloquear" : "Bloquear"}
        </button>
      `;
      row.querySelector("button").addEventListener("click", (e) => {
        toggleAbilityLock(p, e.currentTarget.getAttribute("data-ability"));
        toast(isLocked ? "Habilidade desbloqueada" : "Habilidade bloqueada");
        renderAll(false);
      });
      gmAbilitiesList.appendChild(row);
    });

    if(state.abilities.length === 0){
      gmAbilitiesList.innerHTML = `<div class="muted">Nenhuma habilidade cadastrada.</div>`;
    }
  }

  gmSaveStats.addEventListener("click", () => {
    if(!gmAuthed) return;
    const p = getGMPlayer();

    p.hpMax = Math.max(0, toInt(gmHpMax.value, p.hpMax));
    p.mpMax = Math.max(0, toInt(gmMpMax.value, p.mpMax));
    p.hpNow = clamp(toInt(gmHpNow.value, p.hpNow), 0, p.hpMax);
    p.mpNow = clamp(toInt(gmMpNow.value, p.mpNow), 0, p.mpMax);

    p.pin = String(gmPlayerPin.value || "0000").trim() || "0000";
    p.sprite = String(gmPlayerSprite.value || "ðŸ™‚").trim() || "ðŸ™‚";

    const w = state.combat.gridW, h = state.combat.gridH;
    p.pos = p.pos || {x:0,y:0};
    p.pos.x = clamp(toInt(gmPosX.value, p.pos.x), 0, w-1);
    p.pos.y = clamp(toInt(gmPosY.value, p.pos.y), 0, h-1);

    saveLocal();
    schedulePush("gm_save_player");
    toast("Jogador salvo");
    renderAll(false);
  });

  gmRenamePlayer.addEventListener("click", () => {
    if(!gmAuthed) return;
    const p = getGMPlayer();
    const n = prompt("Novo nome do jogador", p.name);
    if(!n) return;
    p.name = n.trim().slice(0, 40) || p.name;
    saveLocal();
    schedulePush("gm_rename_player");
    toast("Jogador renomeado");
    renderAll(false);
  });

  gmDeletePlayer.addEventListener("click", () => {
    if(!gmAuthed) return;
    if(state.players.length <= 1){ toast("Precisa ter pelo menos 1 jogador"); return; }
    const p = getGMPlayer();
    // CORREÃ‡ÃƒO: Crases no confirm
    if(!confirm(`Remover jogador "${p.name}"?`)) return;
    state.players = state.players.filter(x => x.id !== p.id);
    if(playerAuthedId === p.id) playerLogout();
    selectedGMPlayerId = state.players[0]?.id ?? null;
    saveLocal();
    schedulePush("gm_delete_player");
    toast("Jogador removido");
    renderAll(false);
  });

  btnAddPlayer.addEventListener("click", () => {
    if(!gmAuthed) return;
    const name = prompt("Nome do novo jogador", "Novo HerÃ³i");
    if(!name) return;

    let pin = String(Math.floor(1000 + Math.random()*9000));
    while(state.players.some(p => p.pin === pin)) pin = String(Math.floor(1000 + Math.random()*9000));

    state.players.push({
      id: uid(),
      name: name.trim().slice(0, 40) || "Novo HerÃ³i",
      pin,
      sprite: "ðŸ™‚",
      hpNow: 10, hpMax: 10,
      mpNow: 5, mpMax: 5,
      locked: [],
      pos: { x: 0, y: 0 }
    });

    selectedGMPlayerId = state.players[state.players.length-1].id;
    saveLocal();
    schedulePush("gm_add_player");
    // CORREÃ‡ÃƒO: Crases
    toast(`Jogador criado (PIN: ${pin})`);
    renderAll(false);
  });

  /* abilities create */
  document.getElementById("abCreate").addEventListener("click", () => {
    if(!gmAuthed) return;
    const name = document.getElementById("abName").value.trim();
    const cost = toInt(document.getElementById("abCost").value, 0);
    const tag = document.getElementById("abTag").value.trim();
    const desc = document.getElementById("abDesc").value.trim();
    if(!name){ toast("DÃª um nome para a habilidade"); return; }

    state.abilities.push({
      id: uid(),
      name: name.slice(0, 50),
      cost: Math.max(0, cost),
      tag: (tag || "â€”").slice(0, 18),
      desc: (desc || "").slice(0, 160)
    });

    document.getElementById("abName").value = "";
    document.getElementById("abCost").value = "";
    document.getElementById("abTag").value = "";
    document.getElementById("abDesc").value = "";

    saveLocal();
    schedulePush("gm_create_ability");
    toast("Habilidade adicionada");
    renderAll(false);
  });

  /* backup */
  document.getElementById("btnExport").addEventListener("click", () => {
    if(!gmAuthed) return;
    const blob = new Blob([JSON.stringify(state, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "eldora_state.json";
    document.body.appendChild(a);
    a.click();
    a.remove();
    toast("Exportado");
  });
  const importFile = document.getElementById("importFile");
  document.getElementById("btnImport").addEventListener("click", () => {
    if(!gmAuthed) return;
    importFile.click();
  });
  importFile.addEventListener("change", async () => {
    if(!gmAuthed) return;
    const f = importFile.files?.[0];
    if(!f) return;
    try{
      const txt = await f.text();
      state = normalizeState(JSON.parse(txt));
      saveLocal();
      schedulePush("gm_import");
      toast("Importado");
      renderAll(false);
    }catch(e){
      console.error(e);
      toast("Falha ao importar");
    } finally {
      importFile.value = "";
    }
  });

  /* grid + monster */
  const gridWEl = document.getElementById("gridW");
  const gridHEl = document.getElementById("gridH");
  document.getElementById("gridSave").addEventListener("click", () => {
    if(!gmAuthed) return;
    state.combat.gridW = Math.max(2, toInt(gridWEl.value, state.combat.gridW));
    state.combat.gridH = Math.max(2, toInt(gridHEl.value, state.combat.gridH));

    // clamp positions
    state.players.forEach(p => {
      p.pos = p.pos || {x:0,y:0};
      p.pos.x = clamp(toInt(p.pos.x,0), 0, state.combat.gridW-1);
      p.pos.y = clamp(toInt(p.pos.y,0), 0, state.combat.gridH-1);
    });
    if(state.monster){
      state.monster.pos = state.monster.pos || {x:0,y:0};
      state.monster.pos.x = clamp(toInt(state.monster.pos.x,7), 0, state.combat.gridW-1);
      state.monster.pos.y = clamp(toInt(state.monster.pos.y,4), 0, state.combat.gridH-1);
    }

    saveLocal();
    schedulePush("gm_grid");
    toast("Grid salvo");
    renderAll(false);
  });

  const mName = document.getElementById("mName");
  const mSprite = document.getElementById("mSprite");
  const mPosX = document.getElementById("mPosX");
  const mPosY = document.getElementById("mPosY");
  document.getElementById("mSpawn").addEventListener("click", () => {
    if(!gmAuthed) return;
    const name = (mName.value.trim() || "Monstro").slice(0, 60);
    const sprite = (mSprite.value.trim() || "ðŸ‘¹").slice(0, 200);
    const x = clamp(toInt(mPosX.value, 7), 0, state.combat.gridW-1);
    const y = clamp(toInt(mPosY.value, 4), 0, state.combat.gridH-1);

    state.monster = { name, sprite, pos: { x, y } };
    saveLocal();
    schedulePush("gm_spawn_monster");
    toast("Monstro atualizado");
    renderAll(false);
  });
  document.getElementById("mClear").addEventListener("click", () => {
    if(!gmAuthed) return;
    state.monster = null;
    saveLocal();
    schedulePush("gm_clear_monster");
    toast("Monstro removido");
    renderAll(false);
  });

  function renderGM(){
    renderGMAuth();
    if(!gmAuthed) return;

    // populate players
    populateGMPlayerSelect();
    const p = getGMPlayer();
    if(!p) return;

    gmPlayerName.textContent = p.name;
    gmHpNow.value = String(p.hpNow);
    gmHpMax.value = String(p.hpMax);
    gmMpNow.value = String(p.mpNow);
    gmMpMax.value = String(p.mpMax);
    gmPlayerPin.value = p.pin || "";
    gmPlayerSprite.value = p.sprite || "ðŸ™‚";
    gmPosX.value = String(p.pos?.x ?? 0);
    gmPosY.value = String(p.pos?.y ?? 0);

    renderGMAbilitiesForPlayer(p);

    gridWEl.value = String(state.combat.gridW);
    gridHEl.value = String(state.combat.gridH);

    if(state.monster){
      mName.value = state.monster.name || "";
      mSprite.value = state.monster.sprite || "ðŸ‘¹";
      mPosX.value = String(state.monster.pos?.x ?? 7);
      mPosY.value = String(state.monster.pos?.y ?? 4);
    } else {
      mName.value = "";
      mSprite.value = "ðŸ‘¹";
      mPosX.value = "7";
      mPosY.value = "4";
    }

    renderBattleMaps();
  }

  /* ===== Render All ===== */
  function renderAll(doPush=true){
    state = normalizeState(state);
    renderPlayer();
    renderCombat();
    renderGM();
    saveLocal();
    if(doPush) schedulePush("render");
    updateRoomUI();
  }

  /* Init */
  updateRoomUI();
  renderAll(false);
</script>
</body>
</html>
      
